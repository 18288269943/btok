\section{Формат сообщений защищенного соединения}
\label{CMDS.SM}

Команда и ответ на команду передаются в виде двоичных слов 
$\text{cmd} = \text{CLA} \parallel \text{INS} \parallel \text{P1} \parallel 
\text{P2} \parallel \text{Lc} \parallel \text{CDF} \parallel \text{Le}$ и 
$\text{res} = \text{RDF} \parallel \text{SW1} \parallel \text{SW2}$ 
соответственно (см.~таблицу~\ref{Table.CMDS.Fmt}). 
%
Компоненты Lc, CDF, Le и RDF могут быть пустыми словами, т.~е. отсутствовать.

Команда cmd преобразуются в защищенную команду 
$\text{cmd*} = \text{CLA*} \parallel \text{INS} \parallel \text{P1} 
\parallel \text{P2} \parallel \text{Lс*} \parallel \text{CDF*} 
\parallel \text{Le*}$, а ответ~res~--- в защищенный ответ 
$\text{res*} = \text{RDF*} \parallel \text{SW1} \parallel \text{SW2}$. 
%
В защищенных командах и ответах все компоненты имеют ненулевую длину. 

Компонент CLA* защищенной команды получается из CLA установкой признака 
(бита) защиты, Lc* кодирует длину компонента CDF* (см.~\ref{CMDS.Intro}), 
а Le* всегда устанавливается в $\hex{00}$.   
%
В CDF* включаются зашифрованный компонент CDF (если он непуст), 
компонент Le (если непуст) и имитовставка (обязательно). 

Аналогично компонент RDF* защищенного ответа включает зашифрованный 
компонент RDF (если он непуст) и имитовставку (обязательно). 

При формировании компонентов CDF* и RDF*, включаемые в них объекты данных
кодируются с использованием отличительных правил (см.~\ref{CMDS.Intro}). 
В таблице~\ref{Table.CMDS.CDFRDF} приводятся допустимые объекты, 
указываются их длины и теги, используемые при кодировании. 

\begin{table}[h]
\caption{Объекты данных компонентов CDF* и RDF*}
\label{Table.CMDS.CDFRDF}
\begin{tabular}{|c|c|c|}
\hline
Описание объекта данных & Длина (в октетах) & Тег \\
\hline
\hline
Зашифрованные данные (с индикатором защиты) & не менее 2 & $\hex{87}$ \\
\hline
Длина Le & 1 -- 3 & $\hex{97}$\\
\hline
Статусы SW1 и SW2 & 2 & $\hex{99}$ \\
\hline      
Имитовставка & 8 & $\hex{8E}$ \\
\hline
\end{tabular}
\end{table}

Ниже описываются правила кодирования, которые используются при защите 
команд и ответов. При описании данных правил через~$\len(X)$ обозначается 
длина непустого слова~$X$, закодированная минимально возможным количеством 
октетов согласно~\ref{CMDS.Intro} для случая кодирования компонента Lc. 


\begin{figure}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
CLA & INS & P1 & P2 & Lc & CDF & Le \\
\hline
\hline
\multicolumn{4}{|c|}{заголовок $I$} & [длина CDF] & [сообщение $X$] & [длина ответа]\\
\hline
\end{tabular}

\vskip3pt$\Downarrow$\vskip3pt

\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
CLA* & INS & P1 & P2 & Lc* & CDF* & Le \\
\hline
\hline
\multicolumn{4}{|c|}{заголовок $I^*$} & [длина CDF*] & 
$\left[\der(\hex{87},\hex{02}\parallel Y)\parallel\right]\ 
\left[\der(\hex{97},\text{Le})\parallel\right]\ T$ & $\hex{00}$\\
\hline
\end{tabular}
\end{center}
\caption{Защита команд}\label{Fig.CMDS.Cmd}
\end{figure}

\begin{figure}[!h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
RDF & SW1 & SW2 \\
\hline
\hline
[сообщение $X$] & \multicolumn{2}{|c|}{заголовок $I$} \\
\hline
\end{tabular}

$\Downarrow$

\begin{tabular}{|c|c|c|}
\hline
RDF* & SW1 & SW2 \\
\hline
\hline
$\left[\der(\hex{87},\hex{02}\parallel Y)\parallel\right]\ T$ & 
\multicolumn{2}{|c|}{заголовок $I$} \\
\hline
\end{tabular}
\end{center}
\caption{Защита ответа}\label{Fig.CMDS.Answer}
\end{figure}

{\bf Защита команд}. 
Команда защищается с помощью алгоритма~\ref{CRYPTO.SM.Algs.Encr}. 
При этом в 
качестве заголовка $I$ выступает слово 
$\text{CLA} \parallel \text{INS} \parallel \text{P1} \parallel \text{P2}$ 
(4 октета), а 
в качестве критического сообщения $X$ --- слово CDF (кодовое представление 
длины $X$ задается в компоненте Lc). 

На шаге 2 алгоритма установки защиты заголовок $I$ и зашифрованное сообщение 
$Y$ кодируются с помощью следующего алгоритма: 

\begin{enumerate}
\item
Установить $Z \gets I\oplus\hex{04000000}$.
\item
Если $|Y| > 0$, то $Z \gets Z\parallel\der(\hex{87},\hex{02}\parallel Y)$.
\item
Если $\text{Le} > 0$, то $Z\gets Z\parallel\der(\hex{97}, \text{Le})$.
\item
Возвратить $Z$ в качестве $\langle\langle I, Y\rangle\rangle$.
\end{enumerate}

На шаге 4 алгоритма установки защиты заголовок $I$, защищенное сообщение $Y$ и 
имитовставка $T$ кодируются с помощью следующего алгоритма: 
\begin{enumerate}
\item
Установить $Z\gets I\oplus\hex{04000000}$.
\item
Положить переменную W равной пустому слову.
\item
Если $|Y| > 0$, то $W\gets \der(\hex{87}, \hex{02}\parallel Y)$.
\item
Если $Le > 0$, то $W\gets W\parallel\der(\hex{97}, \text{Le})$.
\item
Установить $W\gets W\parallel\der(\hex{8E}, T)$.
\item
Установить $Z\gets Z\parallel\len(W)\parallel W\parallel\hex{00}$.
\item
Возвратить $Z$ в качестве $\langle\langle I, Y, T\rangle\rangle$.
\end{enumerate}

Кодовое представление $\langle\langle I, Y, T\rangle\rangle$, полученное 
в результате работы алгоритма, представляет собой защищенную команду cmd*. 

{\bf Защита ответов}. 
Ответ защищается с помощью алгоритма~\ref{CRYPTO.SM.Algs.Encr}. При этом в 
качестве заголовка~$I$ выступает слово $\text{SW1} \parallel\text{SW2}$ 
(2 октета), а в качестве критического сообщения $X$~--- слово RDF. 
На шаге 2 алгоритма установки защиты заголовок $I$ и защищенное сообщение $Y$ 
кодируются с помощью следующего алгоритма: 

\begin{enumerate}
\item
$Z\gets \der(\hex{99}, I)$.
\item
Если $|Y| > 0$,  то $Z\gets \der(\hex{87}, \hex{02} \parallel Y) \parallel Z$. 
\item
Возвратить $Z$ в качестве $\langle\langle I, Y \rangle\rangle$.
\end{enumerate}

На шаге 3 алгоритма установки защиты заголовок $I$, защищенное сообщение $Y$ и 
имитовставка $T$ кодируются с помощью следующего алгоритма: 

\begin{enumerate}
\item 
Установить $W\gets\der(\hex{8E}, T)$.
\item 
Если $|Y| > 0$, 
то $W \gets \der(\hex{87}, \hex{02}\parallel Y) \parallel W$.
\item
Установить $Z \gets W \parallel \der(\hex{99}, I)$.
\item
Возвратить $Z$ в качестве $\langle \langle I, Y, T\rangle\rangle$.
\end{enumerate}

Кодовое представление  $\langle\langle I, Y, T \rangle\rangle$, 
полученное в результате работы алгоритма, 
представляет собой защищенный ответ res*. 
В защищенном ответе в поле RDF* передается слово $W$, 
которое является кодовым представлением $Y$ и $T$. 

{\bf Снятие защиты с команд и ответов}. 
%
Снятие защиты с команды и ответа производится с помощью 
алгоритма~\ref{CRYPTO.SM.Algs.Decr}.  
При снятии защиты выполняются обратные к установке защиты действия: 
защищенные команда cmd* и ответ res* преобразуются в исходные команду cmd  
и ответ res.  

{\bf Принудительное закрытие защищенного соединения.}
%
КТ должен принудительно закрыть текущее защищенное соединение только в том случае, 
когда при снятии защиты с команды обнаружено, что: 
\begin{enumerate}
\item[1)] команда представлена в незащищенном виде;
\item[2)] отсутствует необходимый объект данных;
\item[3)] объект данных является некорректным.
\end{enumerate}

В первом и втором случаях КТ должен вернуть 
статус~$\text{SW1} \parallel \text{SW2} = \hex{6987}$, 
а в третьем случае~--- статус~$\text{SW1} \parallel \text{SW2} = 
\hex{6988}$.  

При принудительном закрытии защищенного соединения КТ должен уничтожить 
ключи, используемые для защиты. 
